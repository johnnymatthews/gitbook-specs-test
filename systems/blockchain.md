# Blockchain

The Filecoin Blockchain is a distributed virtual machine that achieves consensus, processes messages, accounts for storage, and maintains security in the Filecoin Protocol. It is the main interface linking various actors in the Filecoin system.

The Filecoin blockchain system includes:

* A [Message Pool](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.message\_pool) subsystem that nodes use to track and propagate messages that miners have declared they want to include in the blockchain.
* A [Virtual Machine](https://spec.filecoin.io/#section-systems.filecoin\_vm) subsystem used to interpret and execute messages in order to update system state.
* A [State Tree](https://spec.filecoin.io/#section-systems.filecoin\_vm.state\_tree) subsystem which manages the creation and maintenance of state trees (the system state) deterministically generated by the vm from a given subchain.
* A [Chain Synchronisation (ChainSync)](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.chainsync) susbystem that tracks and propagates validated message blocks, maintaining sets of candidate chains on which the miner may mine and running syntactic validation on incoming blocks.
* A [Storage Power Consensus](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.storage\_power\_consensus) subsystem which tracks storage state (i.e., [Storage Subystem](https://spec.filecoin.io/#section-systems.filecoin\_mining.storage\_mining)) for a given chain and helps the blockchain system choose subchains to extend and blocks to include in them.

The blockchain system also includes:

* A [Chain Manager](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.struct.chain\_manager), which maintains a given chain’s state, providing facilities to other blockchain subsystems which will query state about the latest chain in order to run, and ensuring incoming blocks are semantically validated before inclusion into the chain.
* A [Block Producer](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.struct.block\_producer) which is called in the event of a successful leader election in order to produce a new block that will extend the current heaviest chain before forwarding it to the syncer for propagation.

At a high-level, the Filecoin blockchain grows through successive rounds of leader election in which a number of miners are elected to generate a block, whose inclusion in the chain will earn them block rewards. Filecoin’s blockchain runs on storage power. That is, its consensus algorithm by which miners agree on which subchain to mine is predicated on the amount of storage backing that subchain. At a high-level, the [Storage Power Consensus](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.storage\_power\_consensus) subsystem maintains a _Power Table_ that tracks the amount of storage that [storage miner actors](https://spec.filecoin.io/#section-systems.filecoin\_mining.storage\_mining) have contributed to the network through _Sector commitments_ and _Proofs of Spacetime_.

## [Blocks](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.struct) <a href="#section-systems.filecoin_blockchain.struct" id="section-systems.filecoin_blockchain.struct"></a>

The Block is the main unit of the Filecoin blockchain, as is also the case with most other blockchains. Block messages are directly linked with Tipsets, which are groups of Block messages as detailed later on in this section. In the following we discuss the main structure of a Block message and the process of validating Block messages in the Filecoin blockchain.

### Block

The Block is the main unit of the Filecoin blockchain.

The Block structure in the Filecoin blockchain is composed of: i) the Block Header, ii) the list of messages inside the block, and iii) the signed messages. This is represented inside the `FullBlock` abstraction. The messages indicate the required set of changes to apply in order to arrive at a deterministic state of the chain.

The Lotus implementation of the block has the following `struct`:

Example: FullBlock

```go
type FullBlock struct {
	Header        *BlockHeader
	BlsMessages   []*Message
	SecpkMessages []*SignedMessage
}
```

> **Note**\
> A block is functionally the same as a block header in the Filecoin protocol. While a block header contains Merkle links to the full system state, messages, and message receipts, a block can be thought of as the full set of this information (not just the Merkle roots, but rather the full data of the state tree, message tree, receipts tree, etc.). Because a full block is large in size, the Filecoin blockchain consists of block headers rather than full blocks. We often use the terms `block` and `block header` interchangeably.

A `BlockHeader` is a canonical representation of a block. BlockHeaders are propagated between miner nodes. From the `BlockHeader` message, a miner has all the required information to apply the associated `FullBlock`’s state and update the chain. In order to be able to do this, the minimum set of information items that need to be included in the `BlockHeader` are shown below and include among others: the miner’s address, the Ticket, the [Proof of SpaceTime](https://spec.filecoin.io/#section-algorithms.pos.post), the CID of the parents where this block evolved from in the IPLD DAG, as well as the messages' own CIDs.

The Lotus implementation of the block header has the following `struct`s:

Example: BlockHeader

```go
type BlockHeader struct {
	Miner address.Address // 0 unique per block/miner

	Ticket                *Ticket            // 1 unique per block/miner: should be a valid VRF
	ElectionProof         *ElectionProof     // 2 unique per block/miner: should be a valid VRF
	BeaconEntries         []BeaconEntry      // 3 identical for all blocks in same tipset
	WinPoStProof          []proof2.PoStProof // 4 unique per block/miner
	Parents               []cid.Cid          // 5 identical for all blocks in same tipset
	ParentWeight          BigInt             // 6 identical for all blocks in same tipset
	Height                abi.ChainEpoch     // 7 identical for all blocks in same tipset
	ParentStateRoot       cid.Cid            // 8 identical for all blocks in same tipset
	ParentMessageReceipts cid.Cid            // 9 identical for all blocks in same tipset
	Messages              cid.Cid            // 10 unique per block
	BLSAggregate          *crypto.Signature  // 11 unique per block: aggrregate of BLS messages from above
	Timestamp             uint64             // 12 identical for all blocks in same tipset / hard-tied to the value of Height above
	BlockSig              *crypto.Signature  // 13 unique per block/miner: miner signature
	ForkSignaling         uint64             // 14 currently unused/undefined
	ParentBaseFee         abi.TokenAmount    // 15 identical for all blocks in same tipset: the base fee after executing parent tipset

	validated bool // internal, true if the signature has been validated
}
```

Example: Ticket

```go
type Ticket struct {
	VRFProof []byte
}
```

Example: ElectionProof

```go
type ElectionProof struct {
	WinCount int64
	VRFProof []byte
}
```

Example: BeaconEntry

```go
type BeaconEntry struct {
	Round uint64
	Data  []byte
}
```

The `BlockHeader` structure has to refer to the TicketWinner of the current round which ensures the correct winner is passed to [ChainSync](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.chainsync).

```go
func IsTicketWinner(vrfTicket []byte, mypow BigInt, totpow BigInt) bool
```

The `Message` structure has to include the source (`From`) and destination (`To`) addresses, a `Nonce` and the `GasPrice`.

The Lotus implementation of the message has the following structure:

Example: Message

```go
type Message struct {
	Version uint64

	To   address.Address
	From address.Address

	Nonce uint64

	Value abi.TokenAmount

	GasLimit   int64
	GasFeeCap  abi.TokenAmount
	GasPremium abi.TokenAmount

	Method abi.MethodNum
	Params []byte
}
```

The message is also validated before it is passed to the [chain synchronization logic](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.chainsync):

Example: ValidForBlockInclusion

```go
func (m *Message) ValidForBlockInclusion(minGas int64, version network.Version) error {
	if m.Version != 0 {
		return xerrors.New("'Version' unsupported")
	}

	if m.To == address.Undef {
		return xerrors.New("'To' address cannot be empty")
	}

	if m.To == build.ZeroAddress && version >= network.Version7 {
		return xerrors.New("invalid 'To' address")
	}

	if m.From == address.Undef {
		return xerrors.New("'From' address cannot be empty")
	}

	if m.Value.Int == nil {
		return xerrors.New("'Value' cannot be nil")
	}

	if m.Value.LessThan(big.Zero()) {
		return xerrors.New("'Value' field cannot be negative")
	}

	if m.Value.GreaterThan(TotalFilecoinInt) {
		return xerrors.New("'Value' field cannot be greater than total filecoin supply")
	}

	if m.GasFeeCap.Int == nil {
		return xerrors.New("'GasFeeCap' cannot be nil")
	}

	if m.GasFeeCap.LessThan(big.Zero()) {
		return xerrors.New("'GasFeeCap' field cannot be negative")
	}

	if m.GasPremium.Int == nil {
		return xerrors.New("'GasPremium' cannot be nil")
	}

	if m.GasPremium.LessThan(big.Zero()) {
		return xerrors.New("'GasPremium' field cannot be negative")
	}

	if m.GasPremium.GreaterThan(m.GasFeeCap) {
		return xerrors.New("'GasFeeCap' less than 'GasPremium'")
	}

	if m.GasLimit > build.BlockGasLimit {
		return xerrors.New("'GasLimit' field cannot be greater than a block's gas limit")
	}

	// since prices might vary with time, this is technically semantic validation
	if m.GasLimit < minGas {
		return xerrors.Errorf("'GasLimit' field cannot be less than the cost of storing a message on chain %d < %d", m.GasLimit, minGas)
	}

	return nil
}
```

#### Block syntax validation

Syntax validation refers to validation that should be performed on a block and its messages _without_ reference to outside information such as the parent state tree. This type of validation is sometimes called _static validation_.

An invalid block must not be transmitted or referenced as a parent.

A syntactically valid block header must decode into fields matching the definitions below, must be a valid CBOR PubSub `BlockMsg` message and must have:

* between 1 and `5*ec.ExpectedLeaders` `Parents` CIDs if `Epoch` is greater than zero (else empty `Parents`),
* a non-negative `ParentWeight`,
* less than or equal to `BlockMessageLimit` number of messages,
* aggregate message CIDs, encapsulated in the `MsgMeta` structure, serialized to the `Messages` CID in the block header,
* a `Miner` address which is an ID-address. The Miner `Address` in the block header should be present and correspond to a public-key address in the current chain state.
* Block signature (`BlockSig`) that belongs to the public-key address retrieved for the Miner
* a non-negative `Epoch`,
* a positive `Timestamp`,
* a `Ticket` with non-empty `VRFResult`,
* `ElectionPoStOutput` containing:
  * a `Candidates` array with between 1 and `EC.ExpectedLeaders` values (inclusive),
  * a non-empty `PoStRandomness` field,
  * a non-empty `Proof` field,
* a non-empty `ForkSignal` field.

A syntactically valid full block must have:

* all referenced messages syntactically valid,
* all referenced parent receipts syntactically valid,
* the sum of the serialized sizes of the block header and included messages is no greater than `block.BlockMaxSize`,
* the sum of the gas limit of all explicit messages is no greater than `block.BlockGasLimit`.

Note that validation of the block signature requires access to the miner worker address and public key from the parent tipset state, so signature validation forms part of semantic validation. Similarly, message signature validation requires lookup of the public key associated with each message’s `From` account actor in the block’s parent state.

#### [**Block semantic validation**](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.struct.block.block-semantic-validation)

Semantic validation refers to validation that requires reference to information outside the block header and messages themselves. Semantic validation relates to the parent tipset and state on which the block is built.

In order to proceed to semantic validation the `FullBlock` must be assembled from the received block header retrieving its Filecoin messages. Block message CIDs can be retrieved from the network and be decoded into valid CBOR `Message`/`SignedMessage`.

In the Lotus implementation the semantic validation of a block is carried out by the `Syncer` module:

Example: ValidateBlock

```go
func (syncer *Syncer) ValidateBlock(ctx context.Context, b *types.FullBlock, useCache bool) (err error) {
	defer func() {
		// b.Cid() could panic for empty blocks that are used in tests.
		if rerr := recover(); rerr != nil {
			err = xerrors.Errorf("validate block panic: %w", rerr)
			return
		}
	}()

	if useCache {
		isValidated, err := syncer.store.IsBlockValidated(ctx, b.Cid())
		if err != nil {
			return xerrors.Errorf("check block validation cache %s: %w", b.Cid(), err)
		}

		if isValidated {
			return nil
		}
	}

	validationStart := build.Clock.Now()
	defer func() {
		stats.Record(ctx, metrics.BlockValidationDurationMilliseconds.M(metrics.SinceInMilliseconds(validationStart)))
		log.Infow("block validation", "took", time.Since(validationStart), "height", b.Header.Height, "age", time.Since(time.Unix(int64(b.Header.Timestamp), 0)))
	}()

	ctx, span := trace.StartSpan(ctx, "validateBlock")
	defer span.End()

	if err := syncer.consensus.ValidateBlock(ctx, b); err != nil {
		return err
	}

	if useCache {
		if err := syncer.store.MarkBlockAsValidated(ctx, b.Cid()); err != nil {
			return xerrors.Errorf("caching block validation %s: %w", b.Cid(), err)
		}
	}

	return nil
}
```

Messages are retrieved through the `Syncer`. There are the following two steps followed by the `Syncer`: 1- Assemble a `FullTipSet` populated with the single block received earlier. The Block’s `ParentWeight` is greater than the one from the (first block of the) heaviest tipset. 2- Retrieve all tipsets from the received Block down to our chain. Validation is expanded to every block inside these tipsets. The validation should ensure that: - Beacon entires are ordered by their round number. - The Tipset `Parents` CIDs match the fetched parent tipset through BlockSync.

A semantically valid block must meet all of the following requirements.

**`Parents`-Related**

* `Parents` listed in lexicographic order of their header’s `Ticket`.
* `ParentStateRoot` CID of the block matches the state CID computed from the parent [Tipset](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.struct.tipset).
* `ParentState` matches the state tree produced by executing the parent tipset’s messages (as defined by the VM interpreter) against that tipset’s parent state.
* `ParentMessageReceipts` identifying the receipt list produced by parent tipset execution, with one receipt for each unique message from the parent tipset. In other words, the Block’s `ParentMessageReceipts` CID matches the receipts CID computed from the parent tipset.
* `ParentWeight` matches the weight of the chain up to and including the parent tipset.

**Time-Related**

* `Epoch` is greater than that of its `Parents`, and
  * not in the future according to the node’s local clock reading of the current epoch,
    * blocks with future epochs should not be rejected, but should not be evaluated (validated or included in a tipset) until the appropriate epoch
  * not farther in the past than the soft finality as defined by SPC [Finality](https://spec.filecoin.io/#section-algorithms.expected\_consensus.finality-in-ec),
    * this rule only applies when receiving new gossip blocks (i.e. from the current chain head), not when syncing to the chain for the first time.
* The `Timestamp` included is in seconds that:
  * must not be bigger than current time plus `ΑllowableClockDriftSecs`
  * must not be smaller than previous block’s `Timestamp` plus `BlockDelay` (including null blocks)
  * is of the precise value implied by the genesis block’s timestamp, the network’s Βlock time and the Βlock’s `Epoch`.

**`Miner`-Related**

* The `Miner` is active in the storage power table in the parent tipset state. The Miner’s address is registered in the `Claims` HAMT of the Power Actor
* The `TipSetState` should be included for each tipset being validated.
  * Every Block in the tipset should belong to different a miner.
* The Actor associated with the message’s `From` address exists, is an account actor and its Nonce matches the message Nonce.
* Valid proofs that the Miner proved access to sealed versions of the sectors it was challenged for are included. In order to achieve that:
  * draw randomness for current epoch with `WinningPoSt` domain separation tag.
  * get list of sectors challanged in this epoch for this miner, based on the randomness drawn.
* Miner is not slashed in `StoragePowerActor`.

**`Beacon`- & `Ticket`-Related**

* Valid `BeaconEntries` should be included:
  * Check that every one of the `BeaconEntries` is a signature of a message: `previousSignature || round` signed using DRAND’s public key.
  * All entries between `MaxBeaconRoundForEpoch` down to `prevEntry` (from previous tipset) should be included.
* A `Ticket` derived from the minimum ticket from the parent tipset’s block headers,
  * `Ticket.VRFResult` validly signed by the `Miner` actor’s worker account public key,
* `ElectionProof Ticket` is computed correctly by checking BLS signature using miner’s key. The `ElectionProof` ticket should be a winning ticket.

**Message- & Signature-Related**

* `secp256k1` messages are correctly signed by their sending actor’s (`From`) worker account key,
* A `BLSAggregate` signature is included that signs the array of CIDs of all the BLS messages referenced by the block with their sending actor’s key.
* A valid `Signature` over the block header’s fields from the block’s `Miner` actor’s worker account public key is included.
* For each message in `ValidForBlockInclusion()` the following hold:
  * Message fields `Version`, `To`, `From`, `Value`, `GasPrice`, and `GasLimit` are correctly defined.
  * Message `GasLimit` is under the message minimum gas cost (derived from chain height and message length).
* For each message in `ApplyMessage` (that is before a message is executed), the following hold:
  * Basic gas and value checks in `checkMessage()`:
    * The Message `GasLimit` is bigger than zero.
    * The Message `GasPrice` and `Value` are set.
  * The Message’s storage gas cost is under the message’s `GasLimit`.
  * The Message’s `Nonce` matches the nonce in the Actor retrieved from the message’s `From` address.
  * The Message’s maximum gas cost (derived from its `GasLimit`, `GasPrice`, and `Value`) is under the balance of the Actor retrieved from message’s `From` address.
  * The Message’s transfer `Value` is under the balance of the Actor retrieved from message’s `From` address.

There is no semantic validation of the messages included in a block beyond validation of their signatures. If all messages included in a block are syntactically valid then they may be executed and produce a receipt.

A chain sync system may perform syntactic and semantic validation in stages in order to minimize unnecessary resource expenditure.

If all of the above tests are successful, the block is marked as validated. Ultimately, an invalid block must not be propagated further or validated as a parent node.

### Tipset

Expected Consensus probabilistically elects multiple leaders in each epoch meaning a Filecoin chain may contain zero or multiple blocks at each epoch (one per elected miner). Blocks from the same epoch are assembled into tipsets. The [VM Interpreter](https://spec.filecoin.io/#section-systems.filecoin\_vm.interpreter) modifies the Filecoin state tree by executing all messages in a tipset (after de-duplication of identical messages included in more than one block).

Each block references a parent tipset and validates _that tipset’s state_, while proposing messages to be included for the current epoch. The state to which a new block’s messages apply cannot be known until that block is incorporated into a tipset. It is thus not meaningful to execute the messages from a single block in isolation: a new state tree is only known once all messages in that block’s tipset are executed.

A valid tipset contains a non-empty collection of blocks that have distinct miners and all specify identical:

* `Epoch`
* `Parents`
* `ParentWeight`
* `StateRoot`
* `ReceiptsRoot`

The blocks in a tipset are canonically ordered by the lexicographic ordering of the bytes in each block’s ticket, breaking ties with the bytes of the CID of the block itself.

Due to network propagation delay, it is possible for a miner in epoch N+1 to omit valid blocks mined at epoch N from their parent tipset. This does not make the newly generated block invalid, it does however reduce its weight and chances of being part of the canonical chain in the protocol as defined by EC’s [Chain Selection](https://spec.filecoin.io/#section-algorithms.expected\_consensus.chain-selection) function.

Block producers are expected to coordinate how they select messages for inclusion in blocks in order to avoid duplicates and thus maximize their expected earnings from message fees (see [Message Pool](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.message\_pool)).

The main Tipset structure in the Lotus implementation includes the following:

Example: TipSet

```go
type TipSet struct {
	cids   []cid.Cid
	blks   []*BlockHeader
	height abi.ChainEpoch
}
```

Semantic validation of a Tipset includes the following checks.

Example: NewTipSet

Checks:

* A tipset is composed of at least one block. (Because of our variable number of blocks per tipset, determined by randomness, we do not impose an upper limit.)
* All blocks have the same height.
* All blocks have the same parents (same number of them and matching CIDs).

```go
func NewTipSet(blks []*BlockHeader) (*TipSet, error) {
	if len(blks) == 0 {
		return nil, xerrors.Errorf("NewTipSet called with zero length array of blocks")
	}

	sort.Slice(blks, tipsetSortFunc(blks))

	var ts TipSet
	ts.cids = []cid.Cid{blks[0].Cid()}
	ts.blks = blks
	for _, b := range blks[1:] {
		if b.Height != blks[0].Height {
			return nil, fmt.Errorf("cannot create tipset with mismatching heights")
		}

		if len(blks[0].Parents) != len(b.Parents) {
			return nil, fmt.Errorf("cannot create tipset with mismatching number of parents")
		}

		for i, cid := range b.Parents {
			if cid != blks[0].Parents[i] {
				return nil, fmt.Errorf("cannot create tipset with mismatching parents")
			}
		}

		ts.cids = append(ts.cids, b.Cid())

	}
	ts.height = blks[0].Height

	return &ts, nil
}
```

### Chain Manager

The _Chain Manager_ is a central component in the blockchain system. It tracks and updates competing subchains received by a given node in order to select the appropriate blockchain head: the latest block of the heaviest subchain it is aware of in the system.

In so doing, the _chain manager_ is the central subsystem that handles bookkeeping for numerous other systems in a Filecoin node and exposes convenience methods for use by those systems, enabling systems to sample randomness from the chain for instance, or to see which block has been finalized most recently.

#### [**Chain Extension**](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.struct.chain\_manager.chain-extension)

[**Incoming block reception**](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.struct.chain\_manager.incoming-block-reception)

For every incoming block, even if the incoming block is not added to the current heaviest tipset, the chain manager should add it to the appropriate subchain it is tracking, or keep track of it independently until either:

* it is able to add to the current heaviest subchain, through the reception of another block in that subchain, or
* it is able to discard it, as the block was mined before finality.

It is important to note that ahead of finality, a given subchain may be abandoned for another, heavier one mined in a given round. In order to rapidly adapt to this, the chain manager must maintain and update all subchains being considered up to finality.

Chain selection is a crucial component of how the Filecoin blockchain works. In brief, every chain has an associated weight accounting for the number of blocks mined on it and so the power (storage) they track. The full details of how selection works are provided in the [Chain Selection](https://spec.filecoin.io/#section-algorithms.expected\_consensus.chain-selection) section.

**Notes/Recommendations:**

1. In order to make certain validation checks simpler, blocks should be indexed by height and by parent set. That way sets of blocks with a given height and common parents may be quickly queried.
2. It may also be useful to compute and cache the resultant aggregate state of blocks in these sets, this saves extra state computation when checking which state root to start a block at when it has multiple parents.
3. It is recommended that blocks are kept in the local datastore regardless of whether they are understood as the best tip at this point - this is to avoid having to refetch the same blocks in the future.

**ChainTipsManager**

The Chain Tips Manager is a subcomponent of Filecoin consensus that is responsible for tracking all live tips of the Filecoin blockchain, and tracking what the current ‘best’ tipset is.

```go
// Returns the ticket that is at round 'r' in the chain behind 'head'
func TicketFromRound(head Tipset, r Round) {}

// Returns the tipset that contains round r (Note: multiple rounds' worth of tickets may exist within a single block due to losing tickets being added to the eventually successfully generated block)
func TipsetFromRound(head Tipset, r Round) {}

// GetBestTipset returns the best known tipset. If the 'best' tipset hasn't changed, then this
// will return the previous best tipset.
func GetBestTipset()

// Adds the losing ticket to the chaintips manager so that blocks can be mined on top of it
func AddLosingTicket(parent Tipset, t Ticket)
```

### Block Producer

#### Mining Blocks

A miner registered with the storage power actor may begin generating and checking election tickets if it has proven storage that meets the [Minimum Miner Size](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.storage\_power\_consensus.minimum-miner-size) threshold requirement.

In order to do so, the miner must be running chain validation, and be keeping track of the most recent blocks received. A miner’s new block will be based on parents from the previous epoch.

**Block Creation**

Producing a block for epoch `H` requires waiting for the beacon entry for that epoch and using it to run `GenerateElectionProof`. If `WinCount` ≥ 1 (i.e., when the miner is elected), the same beacon entry is used to run `WinningPoSt`. Armed by the `ElectionProof` ticket (output of `GenerateElectionProof`) and the `WinningPoSt` proof, the miner can produce an new block.

See [VM Interpreter](https://spec.filecoin.io/#section-systems.filecoin\_vm.interpreter) for details of parent tipset evaluation, and [Block](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.struct.block) for constraints on valid block header values.

To create a block, the eligible miner must compute a few fields:

* `Parents` - the CIDs of the parent tipset’s blocks.
* `ParentWeight` - the parent chain’s weight (see [Chain Selection](https://spec.filecoin.io/#section-algorithms.expected\_consensus.chain-selection)).
* `ParentState` - the CID of the state root from the parent tipset state evaluation (see the [VM Interpreter](https://spec.filecoin.io/#section-systems.filecoin\_vm.interpreter)).
* `ParentMessageReceipts` - the CID of the root of an AMT containing receipts produced while computing `ParentState`.
* `Epoch` - the block’s epoch, derived from the `Parents` epoch and the number of epochs it took to generate this block.
* `Timestamp` - a Unix timestamp, in seconds, generated at block creation.
* `BeaconEntries` - a set of drand entries generated since the last block (see [Beacon Entries](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.storage\_power\_consensus.beacon-entries)).
* `Ticket` - a new ticket generated from that in the prior epoch (see [Ticket Generation](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.storage\_power\_consensus.randomness-ticket-generation)).
* `Miner` - the block producer’s miner actor address.
* `Messages` - The CID of a `TxMeta` object containing message proposed for inclusion in the new block:
  * Select a set of messages from the mempool to include in the block, satisfying block size and gas limits
  * Separate the messages into BLS signed messages and secpk signed messages
  * `TxMeta.BLSMessages`: The CID of the root of an AMT comprising the bare `UnsignedMessage`s
  * `TxMeta.SECPMessages`: the CID of the root of an AMT comprising the `SignedMessage`s
* `BeaconEntries`: a list of beacon entries to derive randomness from
* `BLSAggregate` - The aggregated signature of all messages in the block that used BLS signing.
* `Signature` - A signature with the miner’s worker account private key (must also match the ticket signature) over the block header’s serialized representation (with empty signature).
* `ForkSignaling` - A uint64 flag used as part of signaling forks. Should be set to 0 by default.

Note that the messages to be included in a block need not be evaluated in order to produce a valid block. A miner may wish to speculatively evaluate the messages anyway in order to optimize for including messages which will succeed in execution and pay the most gas.

The block reward is not evaluated when producing a block. It is paid when the block is included in a tipset in the following epoch.

The block’s signature ensures integrity of the block after propagation, since unlike many PoW blockchains, a winning ticket is found independently of block generation.

**Block Broadcast**

An eligible miner propagates the completed block to the network using the [GossipSub](https://spec.filecoin.io/#section-algorithms.gossip\_sub) `/fil/blocks` topic and, assuming everything was done correctly, the network will accept it and other miners will mine on top of it, earning the miner a block reward.

Miners should output their valid block as soon as it is produced, otherwise they risk other miners receiving the block after the EPOCH\_CUTOFF and not including them in the current epoch.

**Block Rewards**

Block rewards are handled by the [Reward Actor](https://spec.filecoin.io/#section-systems.filecoin\_vm.sysactors.rewardactor). Further details on the Block Reward are discussed in the [Filecoin Token](https://spec.filecoin.io/#section-systems.filecoin\_token) section and details about the Block Reward Collateral are discussed in the [Miner Collaterals](https://spec.filecoin.io/#section-systems.filecoin\_mining.miner\_collaterals) section.

## Message Pool

The Message Pool, or `mpool` or `mempool` is a pool of messages in the Filecoin protocol. It acts as the interface between Filecoin nodes and the peer-to-peer network of other nodes used for off-chain message propagation. The message pool is used by nodes to maintain a set of messages they want to transmit to the Filecoin VM and add to the chain (i.e., add for “on-chain” execution).

In order for a message to end up in the blockchain it first has to be in the message pool. In reality, at least in the Lotus implementation of Filecoin, there is no central pool of messages stored somewhere. Instead, the message pool is an abstraction and is realised as a list of messages kept by every node in the network. Therefore, when a node puts a new message in the message pool, this message is propagated to the rest of the network using libp2p’s pubsub protocol, GossipSub. Nodes need to subscribe to the corresponding pubsub topic in order to receive messages.

Message propagation using GossipSub does not happen immediately and therefore, there is some lag before message pools at different nodes can be in sync. In practice, and given continuous streams of messages being added to the message pool and the delay to propagate messages, the message pool is never synchronised across all nodes in the network. This is not a deficiency of the system, as the message pool does not _need_ to be synchronized across the network.

The message pool should have a maximum size defined to avoid DoS attacks, where nodes are spammed and run out of memory. The recommended size for the message pool is 5000 messages.

### Message Propagation

The message pool has to interface with the libp2p pubsub [GossipSub](https://github.com/libp2p/specs/tree/master/pubsub/gossipsub) protocol. This is because messages are propagated over [GossipSub](https://github.com/libp2p/specs/tree/master/pubsub/gossipsub) the corresponding `/fil/msgs/` _topic_. Every [Message](https://spec.filecoin.io/#section-systems.filecoin\_vm.message) is announced in the corresponding `/fil/msgs/` topic by any node participating in the network.

There are two main pubsub topics related to messages and blocks: i) the `/fil/msgs/` topic that carries messages and, ii) the `/fil/blocks/` topic that carries blocks. The `/fil/msgs/` topic is linked to the `mpool`. The process is as follows:

1. When a client wants to send a message in the Filecoin network, they publish the message to the `/fil/msgs/` topic.
2. The message propagates to all other nodes in the network using GossipSub and eventually ends up in the `mpool` of all miners.
3. Depending on cryptoeconomic rules, some miner will eventually pick the message from the `mpool` (together with other messages) and include it in a block.
4. The miner publishes the newly-mined block in the `/fil/blocks/` pubsub topic and the block propagates to all nodes in the network (including the nodes that published the messages included in this block).

Nodes must check that incoming messages are valid, that is, that they have a valid signature. If the message is not valid it should be dropped and must not be forwarded.

The updated, hardened version of the GossipSub protocol includes a number of attack mitigation strategies. For instance, when a node receives an invalid message it assigns a negative _score_ to the sender peer. Peer scores are not shared with other nodes, but are rather kept locally by every peer for all other peers it is interacting with. If a peer’s score drops below a threshold it is excluded from the scoring peer’s mesh. We discuss more details on these settings in the GossipSub section. The full details can be found in the [GossipSub Specification](https://github.com/libp2p/specs/tree/master/pubsub/gossipsub).

NOTES:

* _Fund Checking:_ It is important to note that the `mpool` logic is not checking whether there are enough funds in the account of the message issuer. This is checked by the miner before including a message in a block.
* _Message Sorting:_ Messages are sorted in the `mpool` of miners as they arrive according to cryptoeconomic rules followed by the miner and in order for the miner to compose the next block.

### Message Storage

As mentioned earlier, there is no central pool where messages are included. Instead, every node must have allocated memory for incoming messages.

## ChainSync

Blockchain synchronization (“sync”) is a key part of a blockchain system. It handles retrieval and propagation of blocks and messages, and thus is in charge of distributed state replication. As such, this process is security critical – problems with state replication can have severe consequences to the operation of a blockchain.

When a node first joins the network it discovers peers (through the peer discovery discussed above) and joins the `/fil/blocks` and `/fil/msgs` GossipSub topics. It listens to new blocks being propagated by other nodes. It picks one block as the `BestTargetHead` and starts syncing the blockchain up to this height from the `TrustedCheckpoint`, which by default is the `GenesisBlock` or `GenesisCheckpoint`. In order to pick the `BestTargetHead` the peer is comparing a combination of height and weight - the higher these values the higher the chances of the block being on the main chain. If there are two blocks on the same height, the peer should choose the one with the higher weight. Once the peer chooses the `BestTargetHead` it uses the BlockSync protocol to fetch the blocks and get to the current height. From that point on it is in `CHAIN_FOLLOW` mode, where it uses GossipSub to receive new blocks, or Bitswap if it hears about a block that it has not received through GossipSub.

### ChainSync Overview

`ChainSync` is the protocol Filecoin uses to synchronize its blockchain. It is specific to Filecoin’s choices in state representation and consensus rules, but is general enough that it can serve other blockchains. `ChainSync` is a group of smaller protocols, which handle different parts of the sync process.

Chain synchronisation is generally needed in the following cases:

1. when a node first joins the network and needs to get to the current state before validating or extending the chain.
2. when a node has fell out of sync, e.g., due to a brief disconnection.
3. during normal operation in order to keep up with the latest messages and blocks.

There are three main protocols used to achieve synchronisation for these three cases.

* `GossipSub` is the libp2p pubsub protocol used to propagate messages and blocks. It is mainly used in the third process above when a node needs to stay in sync with new blocks being produced and propagated.
* `BlockSync` is used to synchronise specific parts of the chain, that is from and to a specific height.
* `hello` protocol, which is used when two peers first “meet” (i.e., first time they connect to each other). According to the protocol, they exchange their chain heads.

In addition, `Bitswap` is used to request and receive blocks, when a node is synchonized (“caught up”), but GossipSub has failed to deliver some blocks to a node. Finally, `GraphSync` can be used to fetch parts of the blockchain as a more efficient version of `Bitswap`.

Filecoin nodes are libp2p nodes, and therefore may run a variety of other protocols. As with anything else in Filecoin, nodes MAY opt to use additional protocols to achieve the results. That said, nodes MUST implement the version of `ChainSync` as described in this spec in order to be considered implementations of Filecoin.

### Terms and Concepts

* `LastCheckpoint` the last hard social-consensus oriented checkpoint that `ChainSync` is aware of. This consensus checkpoint defines the minimum finality, and a minimum of history to build on. `ChainSync` takes `LastCheckpoint` on faith, and builds on it, never switching away from its history.
* `TargetHeads` a list of `BlockCIDs` that represent blocks at the fringe of block production. These are the newest and best blocks `ChainSync` knows about. They are “target” heads because `ChainSync` will try to sync to them. This list is sorted by “likelihood of being the best chain”. At this point this is simply realized through `ChainWeight`.
* `BestTargetHead` the single best chain head `BlockCID` to try to sync to. This is the first element of `TargetHeads`

### ChainSync State Machine

At a high level, `ChainSync` does the following:

* **Part 1: Verify internal state (`INIT` state below)**
  * SHOULD verify data structures and validate local chain
  * Resource expensive verification MAY be skipped at nodes' own risk
* **Part 2: Bootstrap to the network (`BOOTSTRAP`)**
  * Step 1. Bootstrap to the network, and acquire a “secure enough” set of peers (more details below)
  * Step 2. Bootstrap to the `GossipSub` channels
* **Part 3: Synchronize trusted checkpoint state (`SYNC_CHECKPOINT`)**
  * Step 1. Start with a `TrustedCheckpoint` (defaults to `GenesisCheckpoint`). The `TrustedCheckpoint` SHOULD NOT be verified in software, it SHOULD be verified by operators.
  * Step 2. Get the block it points to, and that block’s parents
  * Step 3. Fetch the `StateTree`
* **Part 4: Catch up to the chain (`CHAIN_CATCHUP`)**
  * Step 1. Maintain a set of `TargetHeads` (`BlockCIDs`), and select the `BestTargetHead` from it
  * Step 2. Synchronize to the latest heads observed, validating blocks towards them (requesting intermediate points)
  * Step 3. As validation progresses, `TargetHeads` and `BestTargetHead` will likely change, as new blocks at the production fringe will arrive, and some target heads or paths to them may fail to validate.
  * Step 4. Finish when node has “caught up” with `BestTargetHead` (retrieved all the state, linked to local chain, validated all the blocks, etc).
* **Part 5: Stay in sync, and participate in block propagation (`CHAIN_FOLLOW`)**
  * Step 1. If security conditions change, go back to Part 4 (`CHAIN_CATCHUP`)
  * Step 2. Receive, validate, and propagate received `Blocks`
  * Step 3. Now with greater certainty of having the best chain, finalize Tipsets, and advance chain state.

`ChainSync` uses the following _conceptual_ state machine. Since this is a _conceptual_ state machine, implementations MAY deviate from implementing precisely these states, or dividing them strictly. Implementations MAY blur the lines between the states. If so, implementations MUST ensure security of the altered protocol.

<figure><img src="https://spec.filecoin.io/_gen/diagrams/systems/filecoin_blockchain/chainsync/chainsync_fsm.svg?1639060809" alt="ChainSync State Machine" height="100%"><figcaption><p><a href="https://spec.filecoin.io/#figure-chainsync-state-machine">Figure: ChainSync State Machine</a> </p></figcaption></figure>

### Peer Discovery

Peer discovery is a critical part of the overall architecture. Taking this wrong can have severe consequences for the operation of the protocol. The set of peers a new node initially connects to when joining the network may completely dominate the node’s awareness of other peers, and therefore the view of the state of the network that the node has.

Peer discovery can be driven by arbitrary external means and is pushed outside the core functionality of the protocols involved in ChainSync (i.e., GossipSub, Bitswap, BlockSync). This allows for orthogonal, application-driven development and no external dependencies for the protocol implementation. Nonetheless, the GossipSub protocol supports: i) Peer Exchange, and ii) Explicit Peering Agreements.

#### Peer Exchange

Peer Exchange allows applications to bootstrap from a known set of peers without an external peer discovery mechanism. This process can be realized either through bootstrap nodes or other normal peers. **Bootstrap nodes must be maintained by system operators and must be configured correctly.** They have to be stable and operate independently of protocol constructions, such as the GossipSub mesh construction, that is, bootstrap nodes do not maintain connections to the mesh.

For more details on Peer Exchange please refer to the [GossipSub specification](https://github.com/libp2p/specs/tree/master/pubsub/gossipsub).

#### Explicit Peering Agreements

With explicit peering agreements, the operators must specify a list of peers which nodes should connect to when joining. The protocol must have options available for these to be specified. For every explicit peer, the router must establish and maintain a bidirectional (reciprocal) connection.

### Progressive Block Validation

* [Blocks](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.struct.block) may be validated in progressive stages, in order to minimize resource expenditure.
* Validation computation is considerable, and a serious DOS attack vector.
* Secure implementations must carefully schedule validation and minimize the work done by pruning blocks without validating them fully.
* `ChainSync` SHOULD keep a cache of unvalidated blocks (ideally sorted by likelihood of belonging to the chain), and delete unvalidated blocks when they are passed by `FinalityTipset`, or when `ChainSync` is under significant resource load.
* These stages can be used partially across many blocks in a candidate chain, in order to prune out clearly bad blocks long before actually doing the expensive validation work.
* **Progressive Stages of Block Validation**
  * **BV0 - Syntax**: Serialization, typing, value ranges.
  * **BV1 - Plausible Consensus**: Plausible miner, weight, and epoch values (e.g from chain state at `b.ChainEpoch - consensus.LookbackParameter`).
  * **BV2 - Block Signature**
  * **BV3 - Beacon entries**: Valid random beacon entries have been inserted in the block (see [beacon entry validation](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.storage\_power\_consensus.validating-beacon-entries-on-block-reception)).
  * **BV4 - ElectionProof**: A valid election proof was generated.
  * **BV5 - WinningPoSt**: Correct PoSt generated.
  * **BV6 - Chain ancestry and finality**: Verify block links back to trusted chain, not prior to finality.
  * **BV7 - Message Signatures**:
  * **BV8 - State tree**: Parent tipset message execution produces the claimed state tree root and receipts.

## Storage Power Consensus

The Storage Power Consensus (SPC) subsystem is the main interface which enables Filecoin nodes to agree on the state of the system. Storage Power Consensus accounts for individual storage miners' effective power over consensus in given chains in its [Power Table](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.storage\_power\_consensus.storage\_power\_actor.the-power-table). It also runs [Expected Consensus](https://spec.filecoin.io/#section-algorithms.expected\_consensus) (the underlying consensus algorithm in use by Filecoin), enabling storage miners to run leader election and generate new blocks updating the state of the Filecoin system.

Succinctly, the SPC subsystem offers the following services:

* Access to the [Power Table](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.storage\_power\_consensus.storage\_power\_actor.the-power-table) for every subchain, accounting for individual storage miner power and total power on-chain.
* Access to [Expected Consensus](https://spec.filecoin.io/#section-algorithms.expected\_consensus) for individual storage miners, enabling:
  * Access to verifiable randomness [Tickets](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.storage\_power\_consensus.tickets) as provided by [drand](https://spec.filecoin.io/#section-libraries.drand) for the rest of the protocol.
  * Running [Leader Election](https://spec.filecoin.io/#section-algorithms.expected\_consensus.secret-leader-election) to produce new blocks.
  * Running [Chain Selection](https://spec.filecoin.io/#section-algorithms.expected\_consensus.chain-selection) across subchains using EC’s weighting function.
  * Identification of [the most recently finalized tipset](https://spec.filecoin.io/#section-algorithms.expected\_consensus.finality-in-ec), for use by all protocol participants.

### Distinguishing between storage miners and block miners

There are two ways to earn Filecoin tokens in the Filecoin network:

* By participating in the [Storage Market](https://spec.filecoin.io/#section-systems.filecoin\_markets.storage\_market) as a storage provider and being paid by clients for file storage deals.
* By mining new blocks, extending the blockchain, securing the Filecoin consensus mechanism, and running smart contracts to perform state updates as a [Storage Miner](https://spec.filecoin.io/#section-systems.filecoin\_mining.storage\_mining).

There are two types of “miners” (storage and block miners) to be distinguished. [Leader Election](https://spec.filecoin.io/#section-algorithms.expected\_consensus.secret-leader-election) in Filecoin is predicated on a miner’s storage power. Thus, while all block miners will be storage miners, the reverse is not necessarily true.

However, given Filecoin’s “useful Proof-of-Work” is achieved through file storage ( [PoRep](https://spec.filecoin.io/#section-algorithms.pos.porep) and [PoSt](https://spec.filecoin.io/#section-algorithms.pos.post)), there is little overhead cost for storage miners to participate in leader election. Such a [Storage Miner Actor](https://spec.filecoin.io/#section-systems.filecoin\_mining.storage\_mining.storage\_miner\_actor) need only register with the [Storage Power Actor](https://spec.filecoin.io/#section-systems.filecoin\_blockchain.storage\_power\_consensus.storage\_power\_actor) in order to participate in Expected Consensus and mine blocks.

### On Power

Quality-adjusted power is assigned to every sector as a static function of its _**Sector Quality**_ which includes: i) the **Sector Spacetime**, which is the product of the sector size and the promised storage duration, ii) the **Deal Weight** that converts spacetime occupied by deals into consensus power, iii) the **Deal Quality Multiplier** that depends on the type of deal done over the sector (i.e., CC, Regular Deal or Verified Client Deal), and finally, iv) the **Sector Quality Multiplier**, which is an average of deal quality multipliers weighted by the amount of spacetime each type of deal occupies in the sector.

The **Sector Quality** is a measure that maps size, duration and the type of active deals in a sector during its lifetime to its impact on power and reward distribution.

The quality of a sector depends on the deals made over the data inside the sector. There are generally three types of deals: the _Committed Capacity (CC)_, where there is effectively no deal and the miner is storing arbitrary data inside the sector, the _Regular Deals_, where a miner and a client agree on a price in the market and the _Verified Client_ deals, which give more power to the sector. We refer the reader to the [Sector](https://spec.filecoin.io/#section-systems.filecoin\_mining.sector) and [Sector Quality](https://spec.filecoin.io/#section-systems.filecoin\_mining.sector.sector\_quality) sections for details on Sector Types and Sector Quality, the [Verified Clients](https://spec.filecoin.io/#section-algorithms.verified\_clients) section for more details on what a verified client is, and the [CryptoEconomics](https://spec.filecoin.io/#section-algorithms.cryptoecon) section for specific parameter values on the Deal Weights and Quality Multipliers.

**Quality-Adjusted Power** is the number of votes a miner has in the [Secret Leader Election](https://spec.filecoin.io/#section-algorithms.expected\_consensus.secret-leader-election) and has been defined to increase linearly with the useful storage that a miner has committed to the network.

More precisely, we have the following definitions:

* _Raw-byte power_: the size of a sector in bytes.
* _Quality-adjusted power_: the consensus power of stored data on the network, equal to Raw-byte power multiplied by the Sector Quality Multiplier.

### Beacon Entries

The Filecoin protocol uses randomness produced by a [drand](https://spec.filecoin.io/#section-libraries.drand) beacon to seed unbiasable randomness seeds for use in the chain (see [randomness](https://spec.filecoin.io/#section-algorithms.crypto.randomness)).

In turn these random seeds are used by:

* The [sector\_sealer](https://spec.filecoin.io/#section-systems.filecoin\_mining.sector.sealing) as SealSeeds to bind sector commitments to a given subchain.
* The [post\_generator](https://spec.filecoin.io/#section-systems.filecoin\_mining.storage\_proving.poster) as PoStChallenges to prove sectors remain committed as of a given block.
* The Storage Power subsystem as randomness in [Secret Leader Election](https://spec.filecoin.io/#section-algorithms.expected\_consensus.secret-leader-election) to determine how often a miner is chosen to mine a new block.

This randomness may be drawn from various Filecoin chain epochs by the respective protocols that use them according to their security requirements.

It is important to note that a given Filecoin network and a given drand network need not have the same round time, i.e. blocks may be generated faster or slower by Filecoin than randomness is generated by drand. For instance, if the drand beacon is producing randomness twice as fast as Filecoin produces blocks, we might expect two random values to be produced in a Filecoin epoch, conversely if the Filecoin network is twice as fast as drand, we might expect a random value every other Filecoin epoch. Accordingly, depending on both networks' configurations, certain Filecoin blocks could contain multiple or no drand entries. Furthermore, it must be that any call to the drand network for a new randomness entry during an outage should be blocking, as noted with the `drand.Public()` calls below. In all cases, Filecoin blocks must include all drand beacon outputs generated since the last epoch in the `BeaconEntries` field of the block header. Any use of randomness from a given Filecoin epoch should use the last valid drand entry included in a Filecoin block. This is shown below.

#### Get drand randomness for VM

For operations such as PoRep creation, proof validations, or anything that requires randomness for the Filecoin VM, there should be a method that extracts the drand entry from the chain correctly. Note that the round may span multiple filecoin epochs if drand is slower; the lowest epoch number block will contain the requested beacon entry. Similarly, if there has been null rounds where the beacon should have been inserted, we need to iterate on the chain to find where the entry is inserted. Specifically, the next non-null block must contain the drand entry requested by definition.

#### Fetch randomness from drand network

When mining, a miner can fetch entries from the drand network to include them in the new block.

Example: DrandBeacon

DrandBeacon connects Lotus with a drand network in order to provide randomness to the system in a way that’s aligned with Filecoin rounds/epochs.

We connect to drand peers via their public HTTP endpoints. The peers are enumerated in the drandServers variable.

The root trust for the Drand chain is configured from build.DrandChain.

```go
type DrandBeacon struct {
	client dclient.Client

	pubkey kyber.Point

	// seconds
	interval time.Duration

	drandGenTime uint64
	filGenTime   uint64
	filRoundTime uint64

	localCache *lru.Cache
}
```

Example: BeaconEntriesForBlock

```go
func BeaconEntriesForBlock(ctx context.Context, bSchedule Schedule, epoch abi.ChainEpoch, parentEpoch abi.ChainEpoch, prev types.BeaconEntry) ([]types.BeaconEntry, error) {
	{
		parentBeacon := bSchedule.BeaconForEpoch(parentEpoch)
		currBeacon := bSchedule.BeaconForEpoch(epoch)
		if parentBeacon != currBeacon {
			// Fork logic
			round := currBeacon.MaxBeaconRoundForEpoch(epoch)
			out := make([]types.BeaconEntry, 2)
			rch := currBeacon.Entry(ctx, round-1)
			res := <-rch
			if res.Err != nil {
				return nil, xerrors.Errorf("getting entry %d returned error: %w", round-1, res.Err)
			}
			out[0] = res.Entry
			rch = currBeacon.Entry(ctx, round)
			res = <-rch
			if res.Err != nil {
				return nil, xerrors.Errorf("getting entry %d returned error: %w", round, res.Err)
			}
			out[1] = res.Entry
			return out, nil
		}
	}

	beacon := bSchedule.BeaconForEpoch(epoch)

	start := build.Clock.Now()

	maxRound := beacon.MaxBeaconRoundForEpoch(epoch)
	if maxRound == prev.Round {
		return nil, nil
	}

	// TODO: this is a sketchy way to handle the genesis block not having a beacon entry
	if prev.Round == 0 {
		prev.Round = maxRound - 1
	}

	cur := maxRound
	var out []types.BeaconEntry
	for cur > prev.Round {
		rch := beacon.Entry(ctx, cur)
		select {
		case resp := <-rch:
			if resp.Err != nil {
				return nil, xerrors.Errorf("beacon entry request returned error: %w", resp.Err)
			}

			out = append(out, resp.Entry)
			cur = resp.Entry.Round - 1
		case <-ctx.Done():
			return nil, xerrors.Errorf("context timed out waiting on beacon entry to come back for epoch %d: %w", epoch, ctx.Err())
		}
	}

	log.Debugw("fetching beacon entries", "took", build.Clock.Since(start), "numEntries", len(out))
	reverse(out)
	return out, nil
}
```

Example: MaxBeaconRoundForEpoch

```go
func (db *DrandBeacon) MaxBeaconRoundForEpoch(filEpoch abi.ChainEpoch) uint64 {
	// TODO: sometimes the genesis time for filecoin is zero and this goes negative
	latestTs := ((uint64(filEpoch) * db.filRoundTime) + db.filGenTime) - db.filRoundTime
	dround := (latestTs - db.drandGenTime) / uint64(db.interval.Seconds())
	return dround
}
```

#### Validating Beacon Entries on block reception

A Filecoin chain will contain the entirety of the beacon’s output from the Filecoin genesis to the current block.

Given their role in leader election and other critical protocols in Filecoin, a block’s beacon entries must be validated for every block. See [drand](https://spec.filecoin.io/#section-libraries.drand) for details. This can be done by ensuring every beacon entry is a valid signature over the prior one in the chain, using drand’s [`Verify`](https://github.com/drand/drand/blob/763e9a252cf59060c675ced0562e8eba506971c1/chain/beacon.go#L76) endpoint as follows:

Example: ValidateBlockValues

```go
func ValidateBlockValues(bSchedule Schedule, h *types.BlockHeader, parentEpoch abi.ChainEpoch,
	prevEntry types.BeaconEntry) error {
	{
		parentBeacon := bSchedule.BeaconForEpoch(parentEpoch)
		currBeacon := bSchedule.BeaconForEpoch(h.Height)
		if parentBeacon != currBeacon {
			if len(h.BeaconEntries) != 2 {
				return xerrors.Errorf("expected two beacon entries at beacon fork, got %d", len(h.BeaconEntries))
			}
			err := currBeacon.VerifyEntry(h.BeaconEntries[1], h.BeaconEntries[0])
			if err != nil {
				return xerrors.Errorf("beacon at fork point invalid: (%v, %v): %w",
					h.BeaconEntries[1], h.BeaconEntries[0], err)
			}
			return nil
		}
	}

	// TODO: fork logic
	b := bSchedule.BeaconForEpoch(h.Height)
	maxRound := b.MaxBeaconRoundForEpoch(h.Height)
	if maxRound == prevEntry.Round {
		if len(h.BeaconEntries) != 0 {
			return xerrors.Errorf("expected not to have any beacon entries in this block, got %d", len(h.BeaconEntries))
		}
		return nil
	}

	if len(h.BeaconEntries) == 0 {
		return xerrors.Errorf("expected to have beacon entries in this block, but didn't find any")
	}

	last := h.BeaconEntries[len(h.BeaconEntries)-1]
	if last.Round != maxRound {
		return xerrors.Errorf("expected final beacon entry in block to be at round %d, got %d", maxRound, last.Round)
	}

	for i, e := range h.BeaconEntries {
		if err := b.VerifyEntry(e, prevEntry); err != nil {
			return xerrors.Errorf("beacon entry %d (%d - %x (%d)) was invalid: %w", i, e.Round, e.Data, len(e.Data), err)
		}
		prevEntry = e
	}

	return nil
}
```

### Tickets

Filecoin block headers also contain a single “ticket” generated from its epoch’s beacon entry. Tickets are used to break ties in the Fork Choice Rule, for forks of equal weight.

Whenever comparing tickets in Filecoin, the comparison is that of the ticket’s VRF Digest’s bytes.

#### Randomness Ticket generation

At a Filecoin epoch `n`, a new ticket is generated using the appropriate beacon entry for epoch `n`.

The miner runs the beacon entry through a Verifiable Random Function (VRF) to get a new unique ticket. The beacon entry is prepended with the ticket domain separation tag and concatenated with the miner actor address (to ensure miners using the same worker keys get different tickets).

To generate a ticket for a given epoch n:

```
randSeed = GetRandomnessFromBeacon(n)
newTicketRandomness = VRF_miner(H(TicketProdDST || index || Serialization(randSeed, minerActorAddress)))
```

Verifiable Random Functions are used for ticket generation.

#### Ticket Validation

Each Ticket should be generated from the prior one in the VRF-chain and verified accordingly.

### Minimum Miner Size

In order to secure Storage Power Consensus, the system defines a minimum miner size required to participate in consensus.

Specifically, miners must have either at least `MIN_MINER_SIZE_STOR` of power (i.e. storage power currently used in storage deals) in order to participate in leader election. If no miner has `MIN_MINER_SIZE_STOR` or more power, miners with at least as much power as the smallest miner in the top `MIN_MINER_SIZE_TARG` of miners (sorted by storage power) will be able to participate in leader election. In plain english, take `MIN_MINER_SIZE_TARG = 3` for instance, this means that miners with at least as much power as the 3rd largest miner will be eligible to participate in consensus.

Miners smaller than this cannot mine blocks and earn block rewards in the network. Their power will still be counted in the total network (raw or claimed) storage power, even though their power will not be counted as votes for leader election. However, **it is important to note that such miners can still have their power faulted and be penalized accordingly**.

Accordingly, to bootstrap the network, the genesis block must include miners, potentially just CommittedCapacity sectors, to initiate the network.

The `MIN_MINER_SIZE_TARG` condition will not be used in a network in which any miner has more than `MIN_MINER_SIZE_STOR` power. It is nonetheless defined to ensure liveness in small networks (e.g. close to genesis or after large power drops).

### Storage Power Actor

#### `StoragePowerActorState` implementation

Example: State

```go
type State struct {
	TotalRawBytePower abi.StoragePower
	// TotalBytesCommitted includes claims from miners below min power threshold
	TotalBytesCommitted  abi.StoragePower
	TotalQualityAdjPower abi.StoragePower
	// TotalQABytesCommitted includes claims from miners below min power threshold
	TotalQABytesCommitted abi.StoragePower
	TotalPledgeCollateral abi.TokenAmount

	// These fields are set once per epoch in the previous cron tick and used
	// for consistent values across a single epoch's state transition.
	ThisEpochRawBytePower     abi.StoragePower
	ThisEpochQualityAdjPower  abi.StoragePower
	ThisEpochPledgeCollateral abi.TokenAmount
	ThisEpochQAPowerSmoothed  smoothing.FilterEstimate

	MinerCount int64
	// Number of miners having proven the minimum consensus power.
	MinerAboveMinPowerCount int64

	// A queue of events to be triggered by cron, indexed by epoch.
	CronEventQueue cid.Cid // Multimap, (HAMT[ChainEpoch]AMT[CronEvent])

	// First epoch in which a cron task may be stored.
	// Cron will iterate every epoch between this and the current epoch inclusively to find tasks to execute.
	FirstCronEpoch abi.ChainEpoch

	// Claimed power for each miner.
	Claims cid.Cid // Map, HAMT[address]Claim

	ProofValidationBatch *cid.Cid // Multimap, (HAMT[Address]AMT[SealVerifyInfo])
}
```

#### `StoragePowerActor` implementation

Example: Exports&#x20;

```go
func (a Actor) Exports() []interface{} {
	return []interface{}{
		builtin.MethodConstructor: a.Constructor,
		2:                         a.CreateMiner,
		3:                         a.UpdateClaimedPower,
		4:                         a.EnrollCronEvent,
		5:                         a.OnEpochTickEnd,
		6:                         a.UpdatePledgeTotal,
		7:                         nil, // deprecated
		8:                         a.SubmitPoRepForBulkVerify,
		9:                         a.CurrentTotalPower,
	}
}
```

Example: MinerConstructorParams&#x20;

Storage miner actor constructor params are defined here so the power actor can send them to the init actor to instantiate miners. Changed since v2:

* Seal proof type replaced with PoSt proof type

```go
type MinerConstructorParams struct {
	OwnerAddr           addr.Address
	WorkerAddr          addr.Address
	ControlAddrs        []addr.Address
	WindowPoStProofType abi.RegisteredPoStProof
	PeerId              abi.PeerID
	Multiaddrs          []abi.Multiaddrs
}
```

#### The Power Table

The portion of blocks a given miner generates through leader election in EC (and so the block rewards they earn) is proportional to their `Quality-Adjusted Power Fraction` over time. That is, a miner whose quality adjusted power represents 1% of total quality adjusted power on the network should mine 1% of blocks on expectation.

SPC provides a power table abstraction which tracks miner power (i.e. miner storage in relation to network storage) over time. The power table is updated for new sector commitments (incrementing miner power), for failed PoSts (decrementing miner power) or for other storage and consensus faults.

Sector ProveCommit is the first time power is proven to the network and hence power is first added upon successful sector ProveCommit. Power is also added when a sector is declared as recovered. Miners are expected to prove over all their sectors that contribute to their power.

Power is decremented when a sector expires, when a sector is declared or detected to be faulty, or when it is terminated through miner invocation. Miners can also extend the lifetime of a sector through `ExtendSectorExpiration`.

The Miner lifecycle in the power table should be roughly as follows:

* `MinerRegistration`: A new miner with an associated worker public key and address is registered on the power table by the storage mining subsystem, along with their associated sector size (there is only one per worker).
* `UpdatePower`: These power increments and decrements are called by various storage actors (and must thus be verified by every full node on the network). Specifically:
  * Power is incremented at ProveCommit, as a subcall of `miner.ProveCommitSector` or `miner.ProveCommitAggregate`
  * Power of a partition is decremented immediately after a missed WindowPoSt (`DetectedFault`).
  * A particular sector’s power is decremented when it enters into a faulty state either through Declared Faults or Skipped Faults.
  * A particular sector’s power is added back after recovery is declared and proven by PoSt.
  * A particular sector’s power is removed when the sector is expired or terminated through miner invovation.

To summarize, only sectors in the Active state will command power. A Sector becomes Active when it is added upon `ProveCommit`. Power is immediately decremented when it enters into the faulty state. Power will be restored when its declared recovery is proven. A sector’s power is removed when it is expired or terminated through miner invocation.

#### Pledge Collateral

Pledge Collateral is slashed for any fault affecting storage-power consensus, these include:

* faults to expected consensus in particular (see [Consensus Faults](https://spec.filecoin.io/#section-algorithms.expected\_consensus.consensus-faults)), which will be reported by a slasher to the `StoragePowerActor` in exchange for a reward.
* faults affecting consensus power more generally, specifically uncommitted power faults (i.e. [Storage Faults](https://spec.filecoin.io/#section-systems.filecoin\_markets.onchain\_storage\_market.faults.storage-faults)), which will be reported by the `CronActor` automatically or when a miner terminates a sector earlier than its promised duration.

For a more detailed discussion on Pledge Collateral, please see the [Miner Collaterals section](https://spec.filecoin.io/#section-systems.filecoin\_mining.miner\_collaterals).
